
前言： fish在千聊的课已经收尾了。  她的课备得特别好，尤其是代码的注释做得特别好。  是很好的学习材料，我决定从头，重新复现她的可见代码，并把作业做一遍。   扎好基础，重新出发
import pandas as pd
%matplotlib inline


## stock = pd.read_csv('stock',parse_dates =True,index_col='Date')
## !! 文件名后面要加格式，才能被引用啊！  老犯这个错误
stock = pd.read_csv('stock.csv',parse_dates =True,index_col='Date')
stock.head()


stock.shape

(22, 5)

stock.columns

Index(['Open', 'High', 'Low', 'Close', 'Volume'], dtype='object')

stock.describe()
##!!  错误点1 少输入了括号，为什么有些要加括号，有些不加呢？
##  错误点2 ，单词总是打错



stock.plot()

<matplotlib.axes._subplots.AxesSubplot at 0x21d86f6e128>




stock.Close.plot()

<matplotlib.axes._subplots.AxesSubplot at 0x21d86f8c8d0>




接下来是索引和切片
我认为这些事第一课最有价值的地方。
print(stock.Open)
print (stock['Close'])
## @ stock.Open,意味着stock这个文件中的Open这列的数据。 

Date
2017-06-01    153.17
2017-06-02    153.58
2017-06-05    154.34
2017-06-06    153.90
2017-06-07    155.02
2017-06-08    155.25
2017-06-09    155.19
2017-06-12    145.74
2017-06-13    147.16
2017-06-14    147.50
2017-06-15    143.32
2017-06-16    143.78
2017-06-19    143.66
2017-06-20    146.87
2017-06-21    145.52
2017-06-22    145.77
2017-06-23    145.13
2017-06-26    147.17
2017-06-27    145.01
2017-06-28    144.49
2017-06-29    144.71
2017-06-30    144.45
Name: Open, dtype: float64
Date
2017-06-01    153.18
2017-06-02    155.45
2017-06-05    153.93
2017-06-06    154.45
2017-06-07    155.37
2017-06-08    154.99
2017-06-09    148.98
2017-06-12    145.42
2017-06-13    146.59
2017-06-14    145.16
2017-06-15    144.29
2017-06-16    142.27
2017-06-19    146.34
2017-06-20    145.01
2017-06-21    145.87
2017-06-22    145.63
2017-06-23    146.28
2017-06-26    145.82
2017-06-27    143.73
2017-06-28    145.83
2017-06-29    143.68
2017-06-30    144.02
Name: Close, dtype: float64

## 接下来是精确索引，感觉超有用！
print(stock.Close['2017-06-01'])
print(stock['Open']['2017-06-02'])
### 确实很好用，这个功能。


153.18
153.58

stock['Close'][0]


153.18000000000001

stock[['Close']]
### 这个双层方括号，意思是只显示close的列

stock[['Open','Close']]
##@ 这功能真的太好用了吧。  相当于剪切两列数据在一起，然后拼凑成新表格，这excle中，要好多次的操作才能实现哦。 
## 我之前还想 好好地学习excle来增进计算技能，现在看来，不用了耶，直接深挖python的函数和方法，能直接省去好多环节，哈哈哈哈我爱python

.loc 的作用到底是什么呢？
有点不记得了，这次好好体验试试吧
stock.loc['2017-06-01','Close']
## @ 我尝试把日期放在后面，发现不行，原理应该是先读取索引列，这个数据的索引列是“date”，只有先在索引列种寻找，才可以进行下一步。

153.18000000000001

感悟：

直接索引，比如stock.Cloes['2017-06-01]，是从列开始找数据.  是先找到close这列，然后再去找其中的时间对应项。
而.loc则像是先找时间项。
这种感觉就像一个军官，来巡视十字方队的军人。


A军官，从方队的西北角走来，先是横着走，去找到某个士兵
而B军官（.loc），则是竖着走，去找到某个士兵。
那么C军官（.iloc）呢？
慢慢摸索吧

stock.loc[:,'Close']
##@ ：冒号的意思，原本是x：y，即索引列种第x到第y之间的数据，如果只是冒号，那就表示从头到尾全部的列。

Date
2017-06-01    153.18
2017-06-02    155.45
2017-06-05    153.93
2017-06-06    154.45
2017-06-07    155.37
2017-06-08    154.99
2017-06-09    148.98
2017-06-12    145.42
2017-06-13    146.59
2017-06-14    145.16
2017-06-15    144.29
2017-06-16    142.27
2017-06-19    146.34
2017-06-20    145.01
2017-06-21    145.87
2017-06-22    145.63
2017-06-23    146.28
2017-06-26    145.82
2017-06-27    143.73
2017-06-28    145.83
2017-06-29    143.68
2017-06-30    144.02
Name: Close, dtype: float64

stock.loc['2017-06-01':'2017-06-05','Open':'Close']

stock.loc['2017-06-01':'2017-06-05',['Close','Open']]
###@@ .loc[x，y]中的有两个基本参数，x代表基本的索引列参数，即竖着的第一排位置，y代表横着的位置

接下来是iloc时间啦。  我的理解iloc就是军官直接把每个位置都编好了坐标，不再说，第几排的，第几个，而是直接用数字坐标[3，2]，大家都默认这种规则是第三排的第二个人，不再管每排的名称了。
stock.iloc[0,3]

153.18000000000001

那好吧，我就把iloc'索引理解为类似于经纬度的坐标系统吧。
以前我们说我现在的这个个地方，肯定是说“中国-四川-成都-温江”
而，坐标直接说‘北纬30.41.17，东经103.51.55’  索引列就不再那么重要了。
所以iloc是很重要的索引方式，我称之为坐标索引法。

它的索引是从0 开始的，0代表第一位哦 ，大哥


0:3 代表第0，第1，第2. 不包含第3哦

stock.iloc[0:3,0:4]

stock.iloc[0:4,:]

stock['f']=stock['Open']-stock['Close']
stock.head()

stock['Close'].shift(1)
###@ 我的理解这个shift（1）是把那一列往下移动一格。 他的目的是想用昨天的收盘价，减去今天的开盘价，然后来计算闭盘期间发生了什么变化

Date
2017-06-01       NaN
2017-06-02    153.18
2017-06-05    155.45
2017-06-06    153.93
2017-06-07    154.45
2017-06-08    155.37
2017-06-09    154.99
2017-06-12    148.98
2017-06-13    145.42
2017-06-14    146.59
2017-06-15    145.16
2017-06-16    144.29
2017-06-19    142.27
2017-06-20    146.34
2017-06-21    145.01
2017-06-22    145.87
2017-06-23    145.63
2017-06-26    146.28
2017-06-27    145.82
2017-06-28    143.73
2017-06-29    145.83
2017-06-30    143.68
Name: Close, dtype: float64

stock['change']=stock['Close']-stock['Close'].shift(1)
stock.head()

过滤
我的理解是这个过滤相当于筛选功能
stock.Volume>5e7

## 原来这是一个布尔索引啊，不能够直接显示是哪些明细吗？

Date
2017-06-01    False
2017-06-02    False
2017-06-05    False
2017-06-06    False
2017-06-07    False
2017-06-08    False
2017-06-09     True
2017-06-12     True
2017-06-13    False
2017-06-14    False
2017-06-15    False
2017-06-16     True
2017-06-19    False
2017-06-20    False
2017-06-21    False
2017-06-22    False
2017-06-23    False
2017-06-26    False
2017-06-27    False
2017-06-28    False
2017-06-29    False
2017-06-30    False
Name: Volume, dtype: bool

stock[stock.Volume>5e7]
###这功能也太强大了吧
##？？？ 不过为什么一定要先在前面加上文件名称，才能显示成数据呢？

布尔运算是有规则的

and 且
or 或
not 非

## stock[stock.Close>stock.Open&stock.Volume>3e7]
stock[(stock.Close>stock.Open)&(stock.Volume>3e7)]
#!!! 我在原来代码中，没有加括号，这实在是个失误。 为什么呢？其实复杂运算都是要加括号的啊

##@@这是and的关系，并且。就是要满足两个条件才可以的

#接下来是或者关系
stock[(stock.Open>stock.Close)|(stock.change<0)]














#第一题：2017年6月22日当天的收盘价是多少？
stock.loc['2017-6-22','Close']

145.63

##第二题：第二题：** 成交量超过7千万的是哪一天？
stock[stock.Volume>7e7]

#第三题：在2017年6月28日，收盘价减去开盘价是多少？
stock.loc['2017-06-28','Close']-stock.loc['2017-06-28','Open']

1.3400000000000034

#第四题： 开盘价低于144并且成交量大于5千万那一天的收盘价是多少？
stock[(stock.Open<144)&(stock.Volume>5e7)]


stock.change.max()

4.0699999999999932



